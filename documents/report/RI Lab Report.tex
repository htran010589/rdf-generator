\documentclass{acm_proc_article-sp}

\usepackage{pdfpages}
\usepackage{cite}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{url}

\begin{document}

\title{Projection of Binary Predicates}
\numberofauthors{1}
\author{
\alignauthor
Student: Hai Dang Tran\\Matriculation Number: 2557779
}
\date{09 January 2016}

\maketitle

\section{INTRODUCTION}
This report proposes a simple predicate projection algorithm to mine interesting rules from RDF\footnote{\url{https://en.wikipedia.org/wiki/Resource_Description_Framework}} graph. To be specific, the input of the algorithm is a RDF file containing list of subject-predicate-object triples (SPO). The algorithm tends to find types of objects and then project predicate-object pair to more general ones. For example, $marriedTo(singer)$ is in a higher level and more interesting than $marriedTo(Britney)$. Besides, thanks to the projection, the frequency of predicate-object pair can be larger and easier to be explored using rule mining.

The output of the algorithm is a list of SPOs with more projected triples added. This introduces a denser RDF graph and more interesting nonmonotonic rules. Details of the main method will be described in the next section. Finally, some questions for discussion will be mentioned in the last part of the report.

\section{Projection Strategy}

\subsection{Intuition}

The intuition of the method is simple, that is, knowing facts about some types or categories is more interesting than specific individuals. For instance, \textit{hasDuration(short) $\leftarrow$ isMovie(comedy)} is more meaningful than \textit{hasDuration(short) $\leftarrow$ isMovie(lionKingReturns)}. Since the first one reflects a general fact, it can be applied to many other specific movie instances with the same type $comedy$. However, just using types instead of individuals is not trivial as the following examples:

Firstly, \textit{Bill Gates} can be known as a person name, or a name of a movie about someone 's life story. The question is that, with a predicate, how can we choose its suitable types. The intuition is that, of all types for objects corresponding with predicate \textit{marriedTo} predicate, the ratio of \textit{person} is much larger than \textit{movieName}. Thus, we can based on ratio of predicate-type pair frequency over predicate frequency to filter category noises. That is, we just take care about a predicate-type pair if its ratio is greater than a threshold.

Secondly, if we choose a too general level of abstraction, the resulting rules can be trivially true and brings no added information. To be specific, \textit{is(person) $\leftarrow$ is(singer)} is uninteresting, though it has very high confidence. In fact, \textit{person} type has high frequency and can be filtered out using another threshold. In this work, a number $k$ threshold is fixed and when we sort all predicate-type pairs in increasing order of frequency after removing noises, we just get at most top-$k$ types.

The method will be presented formally in the following pseudo-code.

\subsection{Predicate Projection Method}

\begin{algorithm}
\caption{Predicate Projection Algorithm}
\label{algo1}
\begin{algorithmic}
\REQUIRE $L$ as a list of $SPO$ triples
\STATE $R$ $\leftarrow$ empty list
\FOR{each $SPO$ triple from $L$}
\IF{$P$ is type predicate}
\STATE add $O$ to the set of types for $P$
\ENDIF
\STATE poFrequency[PO]++
\STATE pFrequency[P]++
\ENDFOR
\FOR{each $SPO$ triple from $L$}
\FOR{each type $T$ from type set of $O$}
\STATE ptFrequency[PT]++
\ENDFOR
\ENDFOR
\FOR{each $SPO$ triple from $L$}
\IF{poFrequency[PO] > Threshold1}
\STATE add $SPO$ to $R$
\ENDIF
\FOR{each type $T$ from type set of $O$}
\STATE ratio $\leftarrow$ ptFrequency[PT] / pFrequency[P]
\IF{ratio > Threshold2}
\STATE add $T$ to type list TL
\ENDIF
\STATE sort TL in ascending order of ptFrequency
\STATE choose top k types and add corresponding triples to $R$
\ENDFOR
\ENDFOR
\RETURN(R)
\end{algorithmic}
\end{algorithm}

\section{Future Work}

Several approaches for matrix sketching problem are as follows. The first approach tends to find a sparse matrix from the original one. Because of the sparsity, some operations can be performed efficiently on this sketch~\cite{ref1}.


\bibliographystyle{abbrv}
\bibliography{sigproc}

\end{document}
