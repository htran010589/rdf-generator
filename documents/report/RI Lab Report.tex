\documentclass{acm_proc_article-sp}

\usepackage{pdfpages}
\usepackage{cite}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{url}
\usepackage{framed}

\begin{document}

\title{Projection of Binary Predicates}
\numberofauthors{1}
\author{
\alignauthor
Hai Dang Tran\\Matriculation Number: 2557779
}
\date{17 January 2016}

\maketitle

\section{INTRODUCTION}
This report proposes a predicate projection algorithm for an RDF\footnote{\url{https://en.wikipedia.org/wiki/Resource_Description_Framework}} graph. More specifically, given an RDF file containing a list of subject-predicate-object triples ($SPO$), the algorithm \textbf{selects types} for objects and \textbf{projects} binary facts to abstracted unary ones.

\textit{Example 1:} Consider a triple \textit{<Mat marriedTo Britney>}, which can be presented as a fact \textit{marriedTo(Mat, Britney)}. The goal of the algorithm is to select a type of \textit{Britney}, e.g., \textit{singer} among all of the types of this entity, and, construct a unary fact, e.g, \textit{marriedToSinger(Mat)}.


Straightforward creation of unary facts from binary ones, by concatenating a given predicate $P$ in $P(S, O)$ and an object $O$, results in facts of the form $PO(S)$, which are normally very infrequent. Indeed, in example 1, \textit{marriedToBritney(Mat)} most probably is the only fact over the predicate \textit{marriedToBritney}. To tackle the issue, such projection approach is taken into account. Indeed, thanks to this, the frequency of predicate-object pairs is higher and can be easier explored for rule mining.

Details of the main method are described in the next section. Finally, some questions for discussion are mentioned in the last part of the report.

\section{Projection Strategy}

\subsection{Intuition}

The intuition of the method is that, knowing facts about some types or categories is more interesting than specific individuals. For instance, \textit{hasDuration(short) $\leftarrow$ isMovie(comedy)} is more meaningful than \textit{hasDuration(short) $\leftarrow$ isMovie(LionKingReturns)}. Since the first one reflects a general fact, it can be applied to many other specific movie instances with the same type $comedy$. However, naively using all types of individuals has some problems as the following examples demonstrate:

Firstly, \textit{Bill Gates} can be known as a person name, or a name of a movie about the person 's life story. The question is: with a predicate-object pair, how can we choose suitable types of objects for the predicate. The intuition is that, of all types for objects corresponding with predicate \textit{marriedTo} predicate, the ratio of \textit{person} is much larger than \textit{movieName}. Thus, we can filter category noises based on ratio of predicate-type pair frequency over predicate frequency. That is, we just take care of a predicate-type pair if its ratio is greater than a threshold $NOISE\_RATIO$.

Secondly, if we choose a too general level of abstraction, the resulting rules can be trivially true, and thus, not informative. More specifically, \textit{is(person) $\leftarrow$ is(singer)} is uninteresting, though it has very high confidence. In fact, \textit{person} type has high frequency and can be filtered out using another threshold. In this work, a number $TOP\_K$ threshold is fixed and when we sort all predicate-type pairs in increasing order of frequency after removing noises, we just get at most $TOP\_K$ types.

This $TOP\_K$ parameter comes from the intuition that the more times a type appears, the more trivial it is. This is similar to term-frequency\footnote{\url{https://en.wikipedia.org/wiki/Tf-idf}} in Information Retrieval~\cite{ref2}, that is, trivial words like ``the", ``a", ``an", ... have high frequencies. Indeed, \textit{americanSinger} is more interesting than \textit{person} at the first glance. To choose the former instead of the latter, it is expected that $isAmericanSinger$ is has lower frequency than $isPerson$, hence, has higher chance to be in $TOP\_K$.

From these intuitions, the problem statement and solution can be described as in the next section.

\subsection{Predicate Projection Method\\}

\textbf{Definition 1 (Predicate Frequency):} Given a list of SPO triples $L$, $freq(P)$ is the number of triples in $L$ containing $P$ as a predicate.

\textbf{Definition 2 (Predicate-Object Frequency):} Given a list of SPO triples $L$, $freq(PO)$ is the number of triples in $L$ containing $P$ as a predicate and $O$ as an object. If $freq(PO) < MIN\_FREQ$ which is a chosen integer threshold, then $PO$ is called non-popular.

\textbf{Definition 3 (Predicate-Type Frequency and Ratio):} Given a list of SPO triples $L$, $freq(PT)$ is the number of triples in $L$ containing $P$ as a predicate and $O$ as an object of type $T$. Besides, $ratio(PT) = freq(PT) / freq(P)$. $PT$ is called a noise if $ratio(PT) < NOISE\_RATIO$ which is a chosen real threshold.

\textbf{Definition 4 (\textit{TOP\_K} Types of a Predicate-Object Pair):} Given a predicate-object pair $PO$, if we sort all types $T$ of $O$ ($PT$ is not noise) according to the increasing order of $freq(PT)$, then $TOP\_K$ is the first $K$ types.

The problem that we are tackling in this work is now formally stated:

\begin{framed}
\textbf{Problem:} Predicate projection

\textbf{Given:} A list of SPO triples $L$, a real number $NOISE\_RATIO$, two integers $MIN\_FREQ$ and $TOP\_K$

\textbf{Compute:} A list of unary facts $PO(S)$ in which $O$ is an object and $freq(PO) > MIN\_FREQ$. Besides, $R$ may include $PT(S)$ where $T$ is a type, and $T$ is in $TOP\_K$ types of a particular predicate-object pair $PO$.
\end{framed}

Main parameters for Algorithm~\ref{algo1} are $MIN\_FREQ$, $TOP\_K$ and $NOISE\_RATIO$. In brief, there are four steps in this method:
\begin{itemize}
\item Firstly, based on facts containing type predicate, a set of possible types for each object can be found.
\item Secondly, some statistics in above definitions are taken into account.
\item Thirdly, we remove some $SPO$ triples such that the $PO$ is non-popular. For instance, \textit{actedIn(LionKing\\Returns)} is non-popular and can be deleted, but \textit{plays\\For(ManchesterUnited)} should be kept in the new RDF data.
\item Finally, the algorithm focuses on selecting types for objects based on above proposed solution. That is, for each $SPO$ triple, the algorithm takes care of $TOP\_K$ types for $PO$ pair. This is equivalent to projecting object $O$ to several types and add generated facts to the new RDF data.
\end{itemize}

The method is presented formally in the Algorithm~\ref{algo1}. In addition, the code for this method can be found on the Internet\footnote{\url{https://github.com/htran010589/rdf-generator/blob/master/src/imdb/AutoGenRdf.java}}.

\begin{algorithm}[ht]
\caption{Predicate Projection Algorithm}
\label{algo1}
\begin{algorithmic}
\REQUIRE $L$ as a list of $SPO$ triples
\STATE $R$ $\leftarrow$ empty list
\FOR{each $SPO$ triple from $L$}
\IF{$P$ is type predicate}
\STATE add $O$ to the set of types for $P$
\ENDIF
\STATE $freq(PO)++$  //  for predicate-object pair
\STATE $freq(P)++$  //  for predicate
\ENDFOR
\STATE
\FOR{each $SPO$ triple from $L$}
\FOR{each type $T$ from type set of $O$}
\STATE $freq(PT)++$  //  for predicate-type pair
\ENDFOR
\ENDFOR
\STATE
\FOR{each $SPO$ triple from $L$}
\IF{$freq(PO) > MIN\_FREQ$}
\STATE add $SPO$ to $R$
\ENDIF
\STATE
\STATE $TL$ $\leftarrow$ empty list
\FOR{each type $T$ from type set of $O$}
\STATE $ratio(PT) \leftarrow freq(PT) / freq(P)$
\IF{$ratio(PT) > NOISE\_RATIO$}
\STATE add $T$ to type list $TL$
\ENDIF
\ENDFOR
\STATE sort types in $TL$ based on ascending order of predicate-type frequency
\STATE choose $TOP\_K$ types and add corresponding subject-predicate-type triples to $R$
\ENDFOR
\STATE
\RETURN $R$
\end{algorithmic}
\end{algorithm}

\section{Future Work}

The drawbacks of the current work lie in the fact that how can we choose the parameters. Actually the $TOP\_K$ parameter can be different in different predicates and domains while it is fixed in the main method. Besides, how can we figure out what is ratio threshold for noises is still an open question.

These problems can be easier if we narrow the domain, for example, movie, sports or healthcare. In addition, we can add some more predicates in order to mine more interesting rules. To be specific, additional predicates like \textit{directedBy}, \textit{producedBy}, ... are introduced in IMDB experiments. It is expected to have more good results if \textit{actedWith} is added to the data. Instead of manually chosen predicates, the predicate mining can be proposed to dig deeply into.

Besides, when football domain of YAGO3~\cite{ref1} is extracted, there is no fact about \textit{Messi} - a famous footballer. Thus, if we focus on a specific domain, we can collect more facts to enhance rule mining results.

In conclusion, optimizing rule mining for a chosen domain is one of solutions for future work.

\bibliographystyle{abbrv}
\bibliography{sigproc}

\end{document}
